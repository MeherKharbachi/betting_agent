# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/Utils/05_network_architecture.ipynb.

# %% auto 0
__all__ = ['NEW_OBSERVATION_SHAPE', 'N_UNITS', 'CustomEncoder', 'CustomEncoderFactory']

# %% ../../nbs/Utils/05_network_architecture.ipynb 3
import torch
import torch.nn as nn
from d3rlpy.models.encoders import EncoderFactory
from typing import Tuple

# %% ../../nbs/Utils/05_network_architecture.ipynb 5
NEW_OBSERVATION_SHAPE = (18,)
N_UNITS = 64

# %% ../../nbs/Utils/05_network_architecture.ipynb 8
class CustomEncoder(nn.Module):
    "Set up a custom Neural Network to train RL agent."

    def __init__(
        self,
        observation_shape: Tuple,  # Environment observation shape, shape=(30,).
        feature_size: int,  # Number of network outputs (number of environment actions).
        n_units: int = N_UNITS,  # Number of units in each hidden layer.
    ) -> None:
        "Init Neural Network architecture."
        # Initialize self._modules as OrderedDict.
        super(CustomEncoder, self).__init__()
        # Overwrite the observation shape.(observation of the env = (30,))
        # The numerical observation that we processed has a shape of NEW_OBSERVATION_SHAPE.
        observation_shape = NEW_OBSERVATION_SHAPE
        self.feature_size = feature_size
        # First Layer.
        self.fc1 = nn.Linear(observation_shape[0], n_units)
        # 2nd Layer.
        self.fc2 = nn.Linear(n_units, feature_size)

    def forward(
        self,
        x: torch.Tensor,  # Numerical observation.
    ) -> torch.Tensor:
        "Process inputs"
        # Apply ReLU in each layer.
        h = torch.relu(self.fc1(x))
        h = torch.relu(self.fc2(h))
        return h

    # THIS IS IMPORTANT!(for EncoderFactory).
    def get_feature_size(self) -> int:
        "Returns the number of network outputs."
        return self.feature_size

# %% ../../nbs/Utils/05_network_architecture.ipynb 9
class CustomEncoderFactory(EncoderFactory):
    "D3rlpy Custom Encoder."
    # This is necessary to override the EncoderFactory.
    TYPE = "custom"

    def __init__(
        self,
        feature_size: int,  # Number of network outputs (number of environment actions).
    ):
        "Init Encoder"
        # Number of Network outputs.
        self.feature_size = feature_size

    def create(
        self,
        observation_shape: Tuple,  # Environment observation, shape=(30,).
    ):
        # Return the custom DNN.
        return CustomEncoder(observation_shape, self.feature_size)

    def get_params(
        self,
        deep: bool = False,  # Flag to deeply copy objects.
    ):
        "Serialize neural network configuration."
        return {"feature_size": self.feature_size}
